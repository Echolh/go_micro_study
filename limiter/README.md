 # 限流器- 令牌桶

## 令牌桶简介

令牌桶（Token Bucket）是一种经典的流量控制算法，广泛应用于网络限流、API 请求控制、资源访问频率限制等场景。其核心思想是通过 “令牌” 的生成与消耗来控制流量，既能限制长期平均速率，又能允许一定程度的突发流量。


#### 1.令牌生成
 系统以固定速率（如 r 个 / 秒）向一个 “桶” 中放入令牌（Token），桶的容量为 b（最多存放 b 个令牌）。当桶满时，新生成的令牌会被丢弃。
#### 2.流量控制
 每次请求（或操作）需要从桶中获取一定数量的令牌（通常是 1 个）。只有获取到足够的令牌，请求才被允许执行；若令牌不足，请求会被限流（排队等待、延迟处理或直接拒绝）。

#### 3.突发流量处理
由于桶的容量为 b，当短期内有突发请求时，只要桶中积累的令牌足够（不超过 b），就可以一次性处理这些请求，避免了过于严格的限制导致的灵活性不足。


## 实现

代码路径： limiter/token_bucket.go

1. 不是主动定期生成token放入桶中，而是在每次申请令牌的时候，根据申请的时间点计算出桶中应该有多少令牌，跟申请的令牌处理做比较，返回bool值，减去申请的令牌数后更新桶中剩余令牌数。
2. 通过加锁保证桶中关键数据的线程安全
   - 桶中剩余令牌数
   - 上次生成令牌的时间
   - 生成速率



## 心得

### 1. 惰性计算替代定时任务
令牌桶算法的传统实现需后台协程定时填充令牌，但本次采用 ​​惰性计算​​ 替代定时任务，核心思想如下：

1.​按需计算​​

每次请求令牌时（如调用 Allow、Wait），基于当前时间与上次令牌更新时间的时间差，动态计算此期间应生成的令牌数，更新桶内令牌状态。

例：若速率是 10 tokens/s，上次更新在 0.2 秒前，则生成 2 个新令牌。

2.​避免定时器开销​​

省去独立定时协程，减少 Goroutine 调度与内存占用，尤其在高并发场景下更高效。

### 2. 避免重复加锁导致死锁
由于有锁的存在，需要格外注意锁的使用，不要出现重复加锁导致死锁的情况。
针对修改关键数据时，一定要加锁保证线程安全。比如 tokens(剩余令牌数)、last(上一次生成令牌的时间)、limit(生成速率)

```golang
// 示例
type testLock struct {
	mu sync.Mutex
}

// 测试死锁
func TestDeadlock(t *testing.T) {
	tl := &testLock{}
	tl.mu.Lock()
	defer tl.mu.Unlock()
	fmt.Println("TestLock")
	b(tl)

}

func b(tl *testLock) {
	// ! 重复加锁，这里会导致死锁
	tl.mu.Lock()
	defer tl.mu.Unlock()
	fmt.Println("b")
}


// 正确的做法是，删除TestDeadlock中的锁， 在b中加锁即可
func (lim *Limter)A(){
  // b中加锁
   lim.b()

}
```

## test

额外说明： 第一次初始化的时候，是满桶的状态
 
### 请求速率 等于 令牌生成速率
请求速率 等于 令牌生成速率时， 所有请求都能执行成功

```shell
=== RUN   TestLimiterEqualRates
开始发起请求
0获取到令牌，执行成功！
1获取到令牌，执行成功！
2获取到令牌，执行成功！
3获取到令牌，执行成功！
4获取到令牌，执行成功！
5获取到令牌，执行成功！
6获取到令牌，执行成功！
7获取到令牌，执行成功！
8获取到令牌，执行成功！
9获取到令牌，执行成功！
令牌生成速率： 1/秒
请求执行速率：1秒/次
执行成功数: 10
执行失败数: 0
--- PASS: TestLimiterEqualRates (10.01s)
PASS
ok      limiter/test    10.284s

```

### 请求速率 大于 令牌生成速率
 
 部分请求失败

```shell
=== RUN   TestLimiterNotEqualRates
开始发起请求
0获取到令牌，执行成功！
1获取到令牌，执行成功！
2获取到令牌，执行成功！
3未获取到令牌，执行失败.....
4获取到令牌，执行成功！
5未获取到令牌，执行失败.....
6获取到令牌，执行成功！
7未获取到令牌，执行失败.....
8获取到令牌，执行成功！
9未获取到令牌，执行失败.....
令牌生成速率： 1/秒
请求执行速率：0.5秒/次
执行成功数: 6
执行失败数: 4
--- PASS: TestLimiterNotEqualRates (5.01s)
PASS
ok      limiter/test    5.301s

```